
/**
 * @file check.c
 *
 * Functions needed by check.
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: check.c.xsl 14618 2006-02-28 16:08:17Z                                jhb $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

/**
 * @defgroup check Check tree Functions
 *
 * Functions needed by check traversal.
 *
 * @{
 */


#include "check.h"
#include "globals.h"
#include "tree_basic.h"
#include "traverse.h"
#include "dbug.h"
#include "print.h"
#include "check_lib.h"
#include "free.h"
#include "str.h"
#include "memory.h"

/*****************************************************************************
 *
 * @fn node *CHKdoTreeCheck( node *syntax_tree)
 *
 ****************************************************************************/
node *
CHKdoTreeCheck (node * syntax_tree)
{
  DBUG_ENTER ("CHKdoTreeCheck");

  DBUG_PRINT ("CHK", ("Starting the check mechanism"));

  TRAVpush (TR_chk);
  syntax_tree = TRAVdo (syntax_tree, NULL);
  TRAVpop ();

  DBUG_PRINT ("CHK", ("Checkmechanism complete"));

  DBUG_RETURN (syntax_tree);
}

static bool
isDecl (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_fundef) ||
	      (NODE_TYPE (arg_node) == N_globaldec) ||
	      (NODE_TYPE (arg_node) == N_globaldef));
  return (res);
}

static bool
isExpr (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_arrexpr) ||
	      (NODE_TYPE (arg_node) == N_binop) ||
	      (NODE_TYPE (arg_node) == N_bool) ||
	      (NODE_TYPE (arg_node) == N_cast) ||
	      (NODE_TYPE (arg_node) == N_float) ||
	      (NODE_TYPE (arg_node) == N_funcall) ||
	      (NODE_TYPE (arg_node) == N_monop) ||
	      (NODE_TYPE (arg_node) == N_num) ||
	      (NODE_TYPE (arg_node) == N_var));
  return (res);
}

static bool
isStmt (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_assign) ||
	      (NODE_TYPE (arg_node) == N_dowhile) ||
	      (NODE_TYPE (arg_node) == N_exprstmt) ||
	      (NODE_TYPE (arg_node) == N_for) ||
	      (NODE_TYPE (arg_node) == N_if) ||
	      (NODE_TYPE (arg_node) == N_return) ||
	      (NODE_TYPE (arg_node) == N_while));
  return (res);
}

void
isDummy ()
{
  isDecl (NULL);
  isExpr (NULL);
  isStmt (NULL);
}

/** <!--******************************************************************-->
 *
 * @fn CHKarrexpr
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Arrexpr node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKarrexpr (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKarrexpr");

/*
 * Son check: ARREXPR_EXPRS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ARREXPR_EXPRS (arg_node), arg_node,
		   "mandatory son ARREXPR_EXPRS is NULL");
      if (ARREXPR_EXPRS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ARREXPR_EXPRS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ARREXPR_EXPRS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (ARREXPR_EXPRS (arg_node), arg_node,
		   "attribute ARREXPR_EXPRS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ARREXPR_EXPRS (arg_node) != NULL)
    {
      ARREXPR_EXPRS (arg_node) = TRAVdo (ARREXPR_EXPRS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKassign
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Assign node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKassign (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKassign");

/*
 * Son check: ASSIGN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (ASSIGN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (ASSIGN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_EXPR (arg_node), arg_node,
		   "attribute ASSIGN_EXPR must be NULL");
    }

/*
 * Son check: ASSIGN_LET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_LET (arg_node), arg_node,
		   "mandatory son ASSIGN_LET is NULL");
      if (ASSIGN_LET (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ASSIGN_LET (arg_node)) == N_varlet)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_LET hasnt the right type."
					 " It should be: " "N_varlet");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_LET (arg_node), arg_node,
		   "attribute ASSIGN_LET must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_EXPR (arg_node) != NULL)
    {
      ASSIGN_EXPR (arg_node) = TRAVdo (ASSIGN_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_LET (arg_node) != NULL)
    {
      ASSIGN_LET (arg_node) = TRAVdo (ASSIGN_LET (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbinop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BinOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbinop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbinop");

/*
 * Son check: BINOP_LEFT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_LEFT (arg_node), arg_node,
		   "mandatory son BINOP_LEFT is NULL");
      if (BINOP_LEFT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_LEFT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_LEFT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_LEFT (arg_node), arg_node,
		   "attribute BINOP_LEFT must be NULL");
    }

/*
 * Son check: BINOP_RIGHT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_RIGHT (arg_node), arg_node,
		   "mandatory son BINOP_RIGHT is NULL");
      if (BINOP_RIGHT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_RIGHT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_RIGHT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_RIGHT (arg_node), arg_node,
		   "attribute BINOP_RIGHT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_LEFT (arg_node) != NULL)
    {
      BINOP_LEFT (arg_node) = TRAVdo (BINOP_LEFT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_RIGHT (arg_node) != NULL)
    {
      BINOP_RIGHT (arg_node) = TRAVdo (BINOP_RIGHT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbool
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Bool node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbool (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbool");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKcast
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Cast node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKcast (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKcast");

/*
 * Son check: CAST_EXPRESSION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CAST_EXPRESSION (arg_node), arg_node,
		   "mandatory son CAST_EXPRESSION is NULL");
      if (CAST_EXPRESSION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (CAST_EXPRESSION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CAST_EXPRESSION hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (CAST_EXPRESSION (arg_node), arg_node,
		   "attribute CAST_EXPRESSION must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (CAST_EXPRESSION (arg_node) != NULL)
    {
      CAST_EXPRESSION (arg_node) =
	TRAVdo (CAST_EXPRESSION (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdeclarations
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Declarations node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdeclarations (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdeclarations");

/*
 * Son check: DECLARATIONS_DECL 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DECLARATIONS_DECL (arg_node), arg_node,
		   "mandatory son DECLARATIONS_DECL is NULL");
      if (DECLARATIONS_DECL (arg_node) != NULL)
	{
	  if (!((FALSE) || (isDecl (DECLARATIONS_DECL (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLARATIONS_DECL hasnt the right type."
					 " It should be: " "Nodeset: Decl");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLARATIONS_DECL (arg_node), arg_node,
		   "attribute DECLARATIONS_DECL must be NULL");
    }

/*
 * Son check: DECLARATIONS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (DECLARATIONS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (DECLARATIONS_NEXT (arg_node)) ==
		   N_declarations)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLARATIONS_NEXT hasnt the right type."
					 " It should be: " "N_declarations");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLARATIONS_NEXT (arg_node), arg_node,
		   "attribute DECLARATIONS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DECLARATIONS_DECL (arg_node) != NULL)
    {
      DECLARATIONS_DECL (arg_node) =
	TRAVdo (DECLARATIONS_DECL (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DECLARATIONS_NEXT (arg_node) != NULL)
    {
      DECLARATIONS_NEXT (arg_node) =
	TRAVdo (DECLARATIONS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdowhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node DoWhile node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdowhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdowhile");

/*
 * Son check: DOWHILE_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_BLOCK (arg_node), arg_node,
		   "mandatory son DOWHILE_BLOCK is NULL");
      if (DOWHILE_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (DOWHILE_BLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_BLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_BLOCK (arg_node), arg_node,
		   "attribute DOWHILE_BLOCK must be NULL");
    }

/*
 * Son check: DOWHILE_CONDITION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILE_CONDITION (arg_node), arg_node,
		   "mandatory son DOWHILE_CONDITION is NULL");
      if (DOWHILE_CONDITION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (DOWHILE_CONDITION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILE_CONDITION hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILE_CONDITION (arg_node), arg_node,
		   "attribute DOWHILE_CONDITION must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_BLOCK (arg_node) != NULL)
    {
      DOWHILE_BLOCK (arg_node) = TRAVdo (DOWHILE_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILE_CONDITION (arg_node) != NULL)
    {
      DOWHILE_CONDITION (arg_node) =
	TRAVdo (DOWHILE_CONDITION (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKerror
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Error node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKerror (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKerror");

/*
 * Son check: ERROR_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (ERROR_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ERROR_NEXT (arg_node)) == N_error)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ERROR_NEXT hasnt the right type."
					 " It should be: " "N_error");
	    }
	}
    }
  else
    {
      CHKnotExist (ERROR_NEXT (arg_node), arg_node,
		   "attribute ERROR_NEXT must be NULL");
    }

/*
 * Attribute check: ERROR_MESSAGE
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (ERROR_MESSAGE (arg_node), arg_node,
			 "mandatory attribute ERROR_MESSAGE is NULL");
    }
  else
    {
      CHKnotExist (ERROR_MESSAGE (arg_node), arg_node,
		   "attribute ERROR_MESSAGE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ERROR_NEXT (arg_node) != NULL)
    {
      ERROR_NEXT (arg_node) = TRAVdo (ERROR_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKexprs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Exprs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKexprs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKexprs");

/*
 * Son check: EXPRS_EXPRS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (EXPRS_EXPRS (arg_node), arg_node,
		   "mandatory son EXPRS_EXPRS is NULL");
      if (EXPRS_EXPRS (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (EXPRS_EXPRS (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRS_EXPRS hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRS_EXPRS (arg_node), arg_node,
		   "attribute EXPRS_EXPRS must be NULL");
    }

/*
 * Son check: EXPRS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (EXPRS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (EXPRS_NEXT (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRS_NEXT hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRS_NEXT (arg_node), arg_node,
		   "attribute EXPRS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRS_EXPRS (arg_node) != NULL)
    {
      EXPRS_EXPRS (arg_node) = TRAVdo (EXPRS_EXPRS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRS_NEXT (arg_node) != NULL)
    {
      EXPRS_NEXT (arg_node) = TRAVdo (EXPRS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKexprstmt
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Exprstmt node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKexprstmt (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKexprstmt");

/*
 * Son check: EXPRSTMT_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (EXPRSTMT_EXPR (arg_node), arg_node,
		   "mandatory son EXPRSTMT_EXPR is NULL");
      if (EXPRSTMT_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (EXPRSTMT_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRSTMT_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRSTMT_EXPR (arg_node), arg_node,
		   "attribute EXPRSTMT_EXPR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRSTMT_EXPR (arg_node) != NULL)
    {
      EXPRSTMT_EXPR (arg_node) = TRAVdo (EXPRSTMT_EXPR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfloat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Float node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfloat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfloat");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfor
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node For node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfor (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfor");

/*
 * Son check: FOR_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_BLOCK (arg_node), arg_node,
		   "mandatory son FOR_BLOCK is NULL");
      if (FOR_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FOR_BLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_BLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_BLOCK (arg_node), arg_node,
		   "attribute FOR_BLOCK must be NULL");
    }

/*
 * Son check: FOR_START 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_START (arg_node), arg_node,
		   "mandatory son FOR_START is NULL");
      if (FOR_START (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_START (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_START hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_START (arg_node), arg_node,
		   "attribute FOR_START must be NULL");
    }

/*
 * Son check: FOR_STEP 
 */
  if ((FALSE) || (TRUE))
    {
      if (FOR_STEP (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_STEP (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_STEP hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_STEP (arg_node), arg_node,
		   "attribute FOR_STEP must be NULL");
    }

/*
 * Son check: FOR_STOP 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FOR_STOP (arg_node), arg_node,
		   "mandatory son FOR_STOP is NULL");
      if (FOR_STOP (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FOR_STOP (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_STOP hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_STOP (arg_node), arg_node,
		   "attribute FOR_STOP must be NULL");
    }

/*
 * Son check: FOR_SYMBOLTABLE 
 */
  if ((FALSE) || (TRUE))
    {
      if (FOR_SYMBOLTABLE (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FOR_SYMBOLTABLE (arg_node)) == N_symbol)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FOR_SYMBOLTABLE hasnt the right type."
					 " It should be: " "N_symbol");
	    }
	}
    }
  else
    {
      CHKnotExist (FOR_SYMBOLTABLE (arg_node), arg_node,
		   "attribute FOR_SYMBOLTABLE must be NULL");
    }

/*
 * Attribute check: FOR_LOOPVAR
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FOR_LOOPVAR (arg_node), arg_node,
			 "mandatory attribute FOR_LOOPVAR is NULL");
    }
  else
    {
      CHKnotExist (FOR_LOOPVAR (arg_node), arg_node,
		   "attribute FOR_LOOPVAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_BLOCK (arg_node) != NULL)
    {
      FOR_BLOCK (arg_node) = TRAVdo (FOR_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_START (arg_node) != NULL)
    {
      FOR_START (arg_node) = TRAVdo (FOR_START (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_STEP (arg_node) != NULL)
    {
      FOR_STEP (arg_node) = TRAVdo (FOR_STEP (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_STOP (arg_node) != NULL)
    {
      FOR_STOP (arg_node) = TRAVdo (FOR_STOP (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FOR_SYMBOLTABLE (arg_node) != NULL)
    {
      FOR_SYMBOLTABLE (arg_node) =
	TRAVdo (FOR_SYMBOLTABLE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunbody
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunBody node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunbody (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunbody");

/*
 * Son check: FUNBODY_LOCALFUNDEFS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_LOCALFUNDEFS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_LOCALFUNDEFS (arg_node)) == N_fundefs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_LOCALFUNDEFS hasnt the right type."
					 " It should be: " "N_fundefs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_LOCALFUNDEFS (arg_node), arg_node,
		   "attribute FUNBODY_LOCALFUNDEFS must be NULL");
    }

/*
 * Son check: FUNBODY_STATEMENT 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_STATEMENT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_STATEMENT (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_STATEMENT hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_STATEMENT (arg_node), arg_node,
		   "attribute FUNBODY_STATEMENT must be NULL");
    }

/*
 * Son check: FUNBODY_VARDEC 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODY_VARDEC (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODY_VARDEC (arg_node)) == N_vardec)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODY_VARDEC hasnt the right type."
					 " It should be: " "N_vardec");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODY_VARDEC (arg_node), arg_node,
		   "attribute FUNBODY_VARDEC must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_LOCALFUNDEFS (arg_node) != NULL)
    {
      FUNBODY_LOCALFUNDEFS (arg_node) =
	TRAVdo (FUNBODY_LOCALFUNDEFS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_STATEMENT (arg_node) != NULL)
    {
      FUNBODY_STATEMENT (arg_node) =
	TRAVdo (FUNBODY_STATEMENT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODY_VARDEC (arg_node) != NULL)
    {
      FUNBODY_VARDEC (arg_node) =
	TRAVdo (FUNBODY_VARDEC (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundef");

/*
 * Son check: FUNDEF_FUNBODY 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEF_FUNBODY (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_FUNBODY (arg_node)) == N_funbody)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_FUNBODY hasnt the right type."
					 " It should be: " "N_funbody");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_FUNBODY (arg_node), arg_node,
		   "attribute FUNDEF_FUNBODY must be NULL");
    }

/*
 * Son check: FUNDEF_PARAMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEF_PARAMS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNDEF_PARAMS (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_PARAMS hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_PARAMS (arg_node), arg_node,
		   "attribute FUNDEF_PARAMS must be NULL");
    }

/*
 * Son check: FUNDEF_SYMBOLTABLE 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEF_SYMBOLTABLE (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_SYMBOLTABLE (arg_node)) == N_symbol)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_SYMBOLTABLE hasnt the right type."
					 " It should be: " "N_symbol");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_SYMBOLTABLE (arg_node), arg_node,
		   "attribute FUNDEF_SYMBOLTABLE must be NULL");
    }

/*
 * Attribute check: FUNDEF_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNDEF_NAME (arg_node), arg_node,
			 "mandatory attribute FUNDEF_NAME is NULL");
    }
  else
    {
      CHKnotExist (FUNDEF_NAME (arg_node), arg_node,
		   "attribute FUNDEF_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_FUNBODY (arg_node) != NULL)
    {
      FUNDEF_FUNBODY (arg_node) =
	TRAVdo (FUNDEF_FUNBODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_PARAMS (arg_node) != NULL)
    {
      FUNDEF_PARAMS (arg_node) = TRAVdo (FUNDEF_PARAMS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_SYMBOLTABLE (arg_node) != NULL)
    {
      FUNDEF_SYMBOLTABLE (arg_node) =
	TRAVdo (FUNDEF_SYMBOLTABLE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundefs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDefs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundefs (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundefs");

/*
 * Son check: FUNDEFS_FUNDEF 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEFS_FUNDEF (arg_node), arg_node,
		   "mandatory son FUNDEFS_FUNDEF is NULL");
      if (FUNDEFS_FUNDEF (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEFS_FUNDEF (arg_node)) == N_fundef)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEFS_FUNDEF hasnt the right type."
					 " It should be: " "N_fundef");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEFS_FUNDEF (arg_node), arg_node,
		   "attribute FUNDEFS_FUNDEF must be NULL");
    }

/*
 * Son check: FUNDEFS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEFS_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (FUNDEFS_NEXT (arg_node)) == N_fundefs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEFS_NEXT hasnt the right type."
					 " It should be: " "N_fundefs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEFS_NEXT (arg_node), arg_node,
		   "attribute FUNDEFS_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEFS_FUNDEF (arg_node) != NULL)
    {
      FUNDEFS_FUNDEF (arg_node) =
	TRAVdo (FUNDEFS_FUNDEF (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEFS_NEXT (arg_node) != NULL)
    {
      FUNDEFS_NEXT (arg_node) = TRAVdo (FUNDEFS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfuncall
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Funcall node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfuncall (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfuncall");

/*
 * Son check: FUNCALL_ARGS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNCALL_ARGS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNCALL_ARGS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNCALL_ARGS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNCALL_ARGS (arg_node), arg_node,
		   "attribute FUNCALL_ARGS must be NULL");
    }

/*
 * Attribute check: FUNCALL_DECL
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (FUNCALL_DECL (arg_node), arg_node,
		   "attribute FUNCALL_DECL must be NULL");
    }

/*
 * Attribute check: FUNCALL_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (FUNCALL_NAME (arg_node), arg_node,
			 "mandatory attribute FUNCALL_NAME is NULL");
    }
  else
    {
      CHKnotExist (FUNCALL_NAME (arg_node), arg_node,
		   "attribute FUNCALL_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNCALL_ARGS (arg_node) != NULL)
    {
      FUNCALL_ARGS (arg_node) = TRAVdo (FUNCALL_ARGS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldec");

/*
 * Son check: GLOBALDEC_DIMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBALDEC_DIMS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBALDEC_DIMS (arg_node)) == N_ids)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEC_DIMS hasnt the right type."
					 " It should be: " "N_ids");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEC_DIMS (arg_node), arg_node,
		   "attribute GLOBALDEC_DIMS must be NULL");
    }

/*
 * Attribute check: GLOBALDEC_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (GLOBALDEC_NAME (arg_node), arg_node,
			 "mandatory attribute GLOBALDEC_NAME is NULL");
    }
  else
    {
      CHKnotExist (GLOBALDEC_NAME (arg_node), arg_node,
		   "attribute GLOBALDEC_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEC_DIMS (arg_node) != NULL)
    {
      GLOBALDEC_DIMS (arg_node) =
	TRAVdo (GLOBALDEC_DIMS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldef");

/*
 * Son check: GLOBALDEF_DIMS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEF_DIMS (arg_node), arg_node,
		   "mandatory son GLOBALDEF_DIMS is NULL");
      if (GLOBALDEF_DIMS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (GLOBALDEF_DIMS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_DIMS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_DIMS (arg_node), arg_node,
		   "attribute GLOBALDEF_DIMS must be NULL");
    }

/*
 * Son check: GLOBALDEF_INIT 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBALDEF_INIT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (GLOBALDEF_INIT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_INIT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_INIT (arg_node), arg_node,
		   "attribute GLOBALDEF_INIT must be NULL");
    }

/*
 * Attribute check: GLOBALDEF_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (GLOBALDEF_NAME (arg_node), arg_node,
			 "mandatory attribute GLOBALDEF_NAME is NULL");
    }
  else
    {
      CHKnotExist (GLOBALDEF_NAME (arg_node), arg_node,
		   "attribute GLOBALDEF_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_DIMS (arg_node) != NULL)
    {
      GLOBALDEF_DIMS (arg_node) =
	TRAVdo (GLOBALDEF_DIMS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_INIT (arg_node) != NULL)
    {
      GLOBALDEF_INIT (arg_node) =
	TRAVdo (GLOBALDEF_INIT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKids
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Ids node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKids (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKids");

/*
 * Son check: IDS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (IDS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IDS_NEXT (arg_node)) == N_ids)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IDS_NEXT hasnt the right type."
					 " It should be: " "N_ids");
	    }
	}
    }
  else
    {
      CHKnotExist (IDS_NEXT (arg_node), arg_node,
		   "attribute IDS_NEXT must be NULL");
    }

/*
 * Attribute check: IDS_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (IDS_NAME (arg_node), arg_node,
			 "mandatory attribute IDS_NAME is NULL");
    }
  else
    {
      CHKnotExist (IDS_NAME (arg_node), arg_node,
		   "attribute IDS_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (IDS_NEXT (arg_node) != NULL)
    {
      IDS_NEXT (arg_node) = TRAVdo (IDS_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKif
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node If node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKif (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKif");

/*
 * Son check: IF_CONDITION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IF_CONDITION (arg_node), arg_node,
		   "mandatory son IF_CONDITION is NULL");
      if (IF_CONDITION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (IF_CONDITION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_CONDITION hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_CONDITION (arg_node), arg_node,
		   "attribute IF_CONDITION must be NULL");
    }

/*
 * Son check: IF_ELSEBLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      if (IF_ELSEBLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IF_ELSEBLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_ELSEBLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_ELSEBLOCK (arg_node), arg_node,
		   "attribute IF_ELSEBLOCK must be NULL");
    }

/*
 * Son check: IF_IFBLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IF_IFBLOCK (arg_node), arg_node,
		   "mandatory son IF_IFBLOCK is NULL");
      if (IF_IFBLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IF_IFBLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IF_IFBLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (IF_IFBLOCK (arg_node), arg_node,
		   "attribute IF_IFBLOCK must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (IF_CONDITION (arg_node) != NULL)
    {
      IF_CONDITION (arg_node) = TRAVdo (IF_CONDITION (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IF_ELSEBLOCK (arg_node) != NULL)
    {
      IF_ELSEBLOCK (arg_node) = TRAVdo (IF_ELSEBLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IF_IFBLOCK (arg_node) != NULL)
    {
      IF_IFBLOCK (arg_node) = TRAVdo (IF_IFBLOCK (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKmonop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node MonOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKmonop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKmonop");

/*
 * Son check: MONOP_OPERAND 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (MONOP_OPERAND (arg_node), arg_node,
		   "mandatory son MONOP_OPERAND is NULL");
      if (MONOP_OPERAND (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (MONOP_OPERAND (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "MONOP_OPERAND hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (MONOP_OPERAND (arg_node), arg_node,
		   "attribute MONOP_OPERAND must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (MONOP_OPERAND (arg_node) != NULL)
    {
      MONOP_OPERAND (arg_node) = TRAVdo (MONOP_OPERAND (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKnum
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Num node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKnum (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKnum");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKparam
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Param node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKparam (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKparam");

/*
 * Son check: PARAM_DIMS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PARAM_DIMS (arg_node), arg_node,
		   "mandatory son PARAM_DIMS is NULL");
      if (PARAM_DIMS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAM_DIMS (arg_node)) == N_ids)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_DIMS hasnt the right type."
					 " It should be: " "N_ids");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_DIMS (arg_node), arg_node,
		   "attribute PARAM_DIMS must be NULL");
    }

/*
 * Son check: PARAM_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (PARAM_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAM_NEXT (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_NEXT hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_NEXT (arg_node), arg_node,
		   "attribute PARAM_NEXT must be NULL");
    }

/*
 * Attribute check: PARAM_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (PARAM_NAME (arg_node), arg_node,
			 "mandatory attribute PARAM_NAME is NULL");
    }
  else
    {
      CHKnotExist (PARAM_NAME (arg_node), arg_node,
		   "attribute PARAM_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_DIMS (arg_node) != NULL)
    {
      PARAM_DIMS (arg_node) = TRAVdo (PARAM_DIMS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_NEXT (arg_node) != NULL)
    {
      PARAM_NEXT (arg_node) = TRAVdo (PARAM_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKprogram
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Program node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKprogram (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKprogram");

/*
 * Son check: PROGRAM_DECLARATIONS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PROGRAM_DECLARATIONS (arg_node), arg_node,
		   "mandatory son PROGRAM_DECLARATIONS is NULL");
      if (PROGRAM_DECLARATIONS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (PROGRAM_DECLARATIONS (arg_node)) ==
		   N_declarations)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PROGRAM_DECLARATIONS hasnt the right type."
					 " It should be: " "N_declarations");
	    }
	}
    }
  else
    {
      CHKnotExist (PROGRAM_DECLARATIONS (arg_node), arg_node,
		   "attribute PROGRAM_DECLARATIONS must be NULL");
    }

/*
 * Son check: PROGRAM_SYMBOLTABLE 
 */
  if ((FALSE) || (TRUE))
    {
      if (PROGRAM_SYMBOLTABLE (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (PROGRAM_SYMBOLTABLE (arg_node)) == N_symbol)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PROGRAM_SYMBOLTABLE hasnt the right type."
					 " It should be: " "N_symbol");
	    }
	}
    }
  else
    {
      CHKnotExist (PROGRAM_SYMBOLTABLE (arg_node), arg_node,
		   "attribute PROGRAM_SYMBOLTABLE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PROGRAM_DECLARATIONS (arg_node) != NULL)
    {
      PROGRAM_DECLARATIONS (arg_node) =
	TRAVdo (PROGRAM_DECLARATIONS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PROGRAM_SYMBOLTABLE (arg_node) != NULL)
    {
      PROGRAM_SYMBOLTABLE (arg_node) =
	TRAVdo (PROGRAM_SYMBOLTABLE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKreturn
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Return node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKreturn (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKreturn");

/*
 * Son check: RETURN_EXPRESSION 
 */
  if ((FALSE) || (TRUE))
    {
      if (RETURN_EXPRESSION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (RETURN_EXPRESSION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "RETURN_EXPRESSION hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (RETURN_EXPRESSION (arg_node), arg_node,
		   "attribute RETURN_EXPRESSION must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (RETURN_EXPRESSION (arg_node) != NULL)
    {
      RETURN_EXPRESSION (arg_node) =
	TRAVdo (RETURN_EXPRESSION (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKstmts
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Stmts node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKstmts (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKstmts");

/*
 * Son check: STMTS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (STMTS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (STMTS_NEXT (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STMTS_NEXT hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (STMTS_NEXT (arg_node), arg_node,
		   "attribute STMTS_NEXT must be NULL");
    }

/*
 * Son check: STMTS_STMT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (STMTS_STMT (arg_node), arg_node,
		   "mandatory son STMTS_STMT is NULL");
      if (STMTS_STMT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isStmt (STMTS_STMT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STMTS_STMT hasnt the right type."
					 " It should be: " "Nodeset: Stmt");
	    }
	}
    }
  else
    {
      CHKnotExist (STMTS_STMT (arg_node), arg_node,
		   "attribute STMTS_STMT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (STMTS_NEXT (arg_node) != NULL)
    {
      STMTS_NEXT (arg_node) = TRAVdo (STMTS_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (STMTS_STMT (arg_node) != NULL)
    {
      STMTS_STMT (arg_node) = TRAVdo (STMTS_STMT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKsymbol
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Symbol node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKsymbol (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKsymbol");

/*
 * Son check: SYMBOL_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (SYMBOL_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (SYMBOL_NEXT (arg_node)) == N_symbol)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "SYMBOL_NEXT hasnt the right type."
					 " It should be: " "N_symbol");
	    }
	}
    }
  else
    {
      CHKnotExist (SYMBOL_NEXT (arg_node), arg_node,
		   "attribute SYMBOL_NEXT must be NULL");
    }

/*
 * Attribute check: SYMBOL_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (SYMBOL_NAME (arg_node), arg_node,
			 "mandatory attribute SYMBOL_NAME is NULL");
    }
  else
    {
      CHKnotExist (SYMBOL_NAME (arg_node), arg_node,
		   "attribute SYMBOL_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (SYMBOL_NEXT (arg_node) != NULL)
    {
      SYMBOL_NEXT (arg_node) = TRAVdo (SYMBOL_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvar
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Var node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvar (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvar");

/*
 * Son check: VAR_INDICES 
 */
  if ((FALSE) || (TRUE))
    {
      if (VAR_INDICES (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (VAR_INDICES (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VAR_INDICES hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (VAR_INDICES (arg_node), arg_node,
		   "attribute VAR_INDICES must be NULL");
    }

/*
 * Attribute check: VAR_DECL
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (VAR_DECL (arg_node), arg_node,
		   "attribute VAR_DECL must be NULL");
    }

/*
 * Attribute check: VAR_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VAR_NAME (arg_node), arg_node,
			 "mandatory attribute VAR_NAME is NULL");
    }
  else
    {
      CHKnotExist (VAR_NAME (arg_node), arg_node,
		   "attribute VAR_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VAR_INDICES (arg_node) != NULL)
    {
      VAR_INDICES (arg_node) = TRAVdo (VAR_INDICES (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvardec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvardec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvardec");

/*
 * Son check: VARDEC_DIMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDEC_DIMS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (VARDEC_DIMS (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_DIMS hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_DIMS (arg_node), arg_node,
		   "attribute VARDEC_DIMS must be NULL");
    }

/*
 * Son check: VARDEC_INIT 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDEC_INIT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (VARDEC_INIT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_INIT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_INIT (arg_node), arg_node,
		   "attribute VARDEC_INIT must be NULL");
    }

/*
 * Son check: VARDEC_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDEC_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (VARDEC_NEXT (arg_node)) == N_vardec)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_NEXT hasnt the right type."
					 " It should be: " "N_vardec");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_NEXT (arg_node), arg_node,
		   "attribute VARDEC_NEXT must be NULL");
    }

/*
 * Attribute check: VARDEC_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARDEC_NAME (arg_node), arg_node,
			 "mandatory attribute VARDEC_NAME is NULL");
    }
  else
    {
      CHKnotExist (VARDEC_NAME (arg_node), arg_node,
		   "attribute VARDEC_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_DIMS (arg_node) != NULL)
    {
      VARDEC_DIMS (arg_node) = TRAVdo (VARDEC_DIMS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_INIT (arg_node) != NULL)
    {
      VARDEC_INIT (arg_node) = TRAVdo (VARDEC_INIT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_NEXT (arg_node) != NULL)
    {
      VARDEC_NEXT (arg_node) = TRAVdo (VARDEC_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvarlet
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarLet node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvarlet (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvarlet");

/*
 * Son check: VARLET_INDICES 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARLET_INDICES (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (VARLET_INDICES (arg_node)) == N_exprs)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARLET_INDICES hasnt the right type."
					 " It should be: " "N_exprs");
	    }
	}
    }
  else
    {
      CHKnotExist (VARLET_INDICES (arg_node), arg_node,
		   "attribute VARLET_INDICES must be NULL");
    }

/*
 * Attribute check: VARLET_DECL
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (VARLET_DECL (arg_node), arg_node,
		   "attribute VARLET_DECL must be NULL");
    }

/*
 * Attribute check: VARLET_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARLET_NAME (arg_node), arg_node,
			 "mandatory attribute VARLET_NAME is NULL");
    }
  else
    {
      CHKnotExist (VARLET_NAME (arg_node), arg_node,
		   "attribute VARLET_NAME must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARLET_INDICES (arg_node) != NULL)
    {
      VARLET_INDICES (arg_node) =
	TRAVdo (VARLET_INDICES (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKwhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node While node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKwhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKwhile");

/*
 * Son check: WHILE_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_BLOCK (arg_node), arg_node,
		   "mandatory son WHILE_BLOCK is NULL");
      if (WHILE_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (WHILE_BLOCK (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_BLOCK hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_BLOCK (arg_node), arg_node,
		   "attribute WHILE_BLOCK must be NULL");
    }

/*
 * Son check: WHILE_CONDITION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILE_CONDITION (arg_node), arg_node,
		   "mandatory son WHILE_CONDITION is NULL");
      if (WHILE_CONDITION (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (WHILE_CONDITION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILE_CONDITION hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILE_CONDITION (arg_node), arg_node,
		   "attribute WHILE_CONDITION must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_BLOCK (arg_node) != NULL)
    {
      WHILE_BLOCK (arg_node) = TRAVdo (WHILE_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (WHILE_CONDITION (arg_node) != NULL)
    {
      WHILE_CONDITION (arg_node) =
	TRAVdo (WHILE_CONDITION (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

typedef enum
{ CHK_binop_op,
  CHK_bool_value,
  CHK_cast_type,
  CHK_error_message,
  CHK_float_value,
  CHK_for_loopvar,
  CHK_fundef_type,
  CHK_funcall_name,
  CHK_globaldec_type,
  CHK_globaldef_type,
  CHK_ids_name,
  CHK_monop_op,
  CHK_num_value,
  CHK_param_type,
  CHK_symbol_type,
  CHK_var_name,
  CHK_vardec_type,
  CHK_varlet_name,
} attr_list;
